---
title: "Sensitivity of MPA rasters to MPA size"
author: '*Compiled on `r date()` by `r Sys.info()["user"]`*'
output:
  html_document:
    code_folding: hide
    highlight: haddock
    includes:
      in_header: ~/github/src/templates/ohara_hdr.html
    number_sections: no
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
    toc_depth: '3'
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = FALSE, message = FALSE, warning = FALSE)

library(raster)
library(sf)
library(fasterize)
library(latex2exp)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')  ###

dir_git <- here('../spp_risk_dists')

### goal specific folders and info
dir_spatial <- file.path(dir_git, '_spatial')
dir_o_anx   <- file.path(dir_O, 'git-annex/spp_risk_dists')
dir_wdpa <- file.path(dir_o_anx, 'wdpa')
dir_sa   <- file.path(dir_wdpa, 'sensitivity_analysis')

gp_proj4 <- '+proj=cea +lon_0=0 +lat_ts=45 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs'

```

### Small MPA coverage as a proportion of global MPA estate

```{r create wdpa marine shapefile}

mpa_poly_file    <- file.path(dir_sa, 'mpa_by_cat_jun2018.shp')
notake_poly_file <- file.path(dir_sa, 'mpa_notake_jun2018.shp')

if(!file.exists(mpa_poly_file)) {

  wdpa_poly_file <- file.path(dir_wdpa, 
                              'wdpa_jun2018/WDPA_June2018-shapefile-polygons.shp')
  wdpa_poly <- sf::read_sf(wdpa_poly_file)

  # wdpa_poly$IUCN_CAT %>% unique()
  iucn_cats <- c('Ia'  = 1,
                 'Ib'  = 1,
                 'II'  = 2,
                 'III' = 3,
                 'IV'  = 4,
                 'V'   = 5,
                 'VI'  = 6)
  
  mpa_poly <- wdpa_poly %>%
    filter(MARINE > 0 | GIS_M_AREA > 0) %>%
    filter(STATUS %in% c('Designated', 'Adopted', 'Established')) %>%
      ### no paper parks!
    filter(!str_detect(tolower(MANG_PLAN), 'non-mpa')) %>%
      ### omit non-MPA fisheries or species management plans!
    mutate(NO_TAKE = ifelse(WDPAID == 309888, TRUE, NO_TAKE),
             ### patch PIPA to be no take - currently "not reported"
           no_take = (NO_TAKE == 'All') | (NO_TAKE == 'Part' & NO_TK_AREA > 0.75 * GIS_M_AREA),
             ### if NO_TK_AREA is 75% or more of GIS area, count it...
           cat = iucn_cats[IUCN_CAT],
           cat = ifelse(no_take & !cat %in% 1:2, -1, cat), ### use -1 as an "other no take" flag
           cat = ifelse(is.na(cat), 8, cat)) %>% ### use 8 as an "other protected" flag
    mutate(area_km2 = st_area(geometry) / 1e6 %>% as.numeric()) %>%
    arrange(area_km2) %>%
    mutate(id  = 1:n()) %>%           ### set a unique number ID for each polygon
    st_transform(crs = gp_proj4) %>%
    select(id, cat, area_km2, NAME, DESIG = DESIG_ENG, IUCN_CAT, 
           MARINE, no_take, stat_yr = STATUS_YR, ISO3,
           geometry) %>%
    clean_df_names()
  
  write_sf(mpa_poly, mpa_poly_file)
  
  ### notake_poly will have different identifiers, and in order of area
  notake_poly <- mpa_poly %>%
    filter(cat <= 2) %>%
    arrange(area_km2) %>%
    mutate(id = 1:n())
  write_sf(notake_poly, notake_poly_file)
  
}
  
```

```{r summarize MPA polys all}

mpa_poly_df <- foreign::read.dbf(str_replace(mpa_poly_file, '.shp', '.dbf')) %>%
  arrange(area_km2) %>%
  mutate(cum_area = cumsum(area_km2))

mpa_poly_small <- mpa_poly_df %>%
  mutate(`MPA size` = case_when(area_km2 < 1 ~ '< 1 km^2',
                          area_km2 < 100 ~ '< 100 km^2', 
                          area_km2 < 1000 ~ '< 1000 km^2', 
                          TRUE ~ '>= 1000 km^2')) %>%
  group_by(`MPA size`) %>%
  summarize(`A total, km²` = sum(area_km2),
            N = n()) %>%
  mutate(`% MPA by count` = N / sum(N) * 100,
         `% MPA by area` = `A total, km²` / sum(`A total, km²`) * 100)

write_csv(mpa_poly_small, 'tableSM1_mpa_small.csv')

```

``` {r summarize mpas no take}

marine_notake_df <- mpa_poly_df %>%
  filter(cat <= 2) %>%
  arrange(area_km2) %>%
  mutate(cum_area = cumsum(area_km2))

marine_notake_small <- marine_notake_df %>%
  mutate(`MPA size` = case_when(area_km2 < 1 ~ '< 1 km^2',
                          area_km2 < 100 ~ '< 100 km^2', 
                          area_km2 < 1000 ~ '< 1000 km^2', 
                          TRUE ~ '>= 1000 km^2')) %>%
  group_by(`MPA size`) %>%
  summarize(`A total, km²` = sum(area_km2),
            N = n()) %>%
  mutate(`% MPA by count` = N / sum(N) * 100,
         `% MPA by area` = `A total, km²` / sum(`A total, km²`) * 100)

write_csv(marine_notake_small, 'tableSM2_notake_small.csv')
```

```{r plot area density}

dens_plot1_all <- ggplot(x <- mpa_poly_df,
       aes(x = area_km2)) +
  ggtheme_plot() +
  geom_density(fill = 'grey30', color = NA, alpha = .6) +
  geom_vline(xintercept = 100, color = 'red', size = .25) +
  geom_vline(xintercept = 1, color = 'blue', linetype = 'dashed', size = .25) +
  scale_x_log10(limits = c(.001, NA), breaks = 10^(-3:6)) +
  labs(x = 'MPA Area, km²',
       title = 'Distribution of MPAs by size')

dens_plot1_no_take <- ggplot(x <- marine_notake_df,
       aes(x = area_km2)) +
  ggtheme_plot() +
  geom_density(fill = 'grey30', color = NA, alpha = .6) +
  geom_vline(xintercept = 100, color = 'red', size = .25) +
  geom_vline(xintercept = 1, color = 'blue', linetype = 'dashed', size = .25) +
  scale_x_log10(limits = c(.001, NA), breaks = 10^(-3:6)) +
  labs(x = 'No-take MPA Area, km²',
       title = 'Distribution of no-take MPAs by size')

dens_plot1 <- cowplot::plot_grid(dens_plot1_all, dens_plot1_no_take, 
                                 labels = c('A', 'B'), nrow = 2)

ggsave(plot = dens_plot1, filename = 'sm1_area_density.png', 
       height = 4, width = 5, dpi = 300)

```

```{r plot cum area}

plot1_all <- ggplot(x <- mpa_poly_df %>% 
         filter(id %% 10 == 0 | id > 17800), 
           ### thin the data set a bit to see if those lines go away... doesn't affect cum sum
       aes(x = area_km2, y = cum_area)) +
  ggtheme_plot() +
  geom_area(fill = 'grey30', color = NA,  alpha = .6) +
  geom_vline(xintercept = 100, color = 'red', size = .25) +
  geom_vline(xintercept = 1, color = 'blue', linetype = 'dashed', size = .25) +
  scale_x_log10(limits = c(.1, NA), breaks = 10^(-1:6)) +
  labs(x = 'MPA Area, km²',
       y = 'Cum. area, km²',
       title = 'MPA size vs. cumulative protected area, all MPAs')

plot1_no_take <- ggplot(marine_notake_df, aes(x = area_km2, y = cum_area)) +
  ggtheme_plot() +
  geom_area(fill = 'grey30', color = NA, alpha = .6) +
  geom_vline(xintercept = 100, color = 'red', size = .25) +
  geom_vline(xintercept = 1, color = 'blue', linetype = 'dashed', size = .25) +
  scale_x_log10(limits = c(0.1, NA), breaks = 10^(-1:6)) +
  labs(x = 'No-take MPA Area, km²',
       y = 'Cum. area, km²',
       title = 'MPA size vs. cumulative protected area, no-take MPAs')

plot1 <- cowplot::plot_grid(plot1_all, plot1_no_take, 
                            labels = c('A', 'B'), nrow = 2)

ggsave(plot = plot1, filename = 'sm2_cum_area.png', 
       height = 4, width = 5, dpi = 300)

```

![](sm1_area_density.png)

![](sm2_cum_area.png)


`r knitr::kable(mpa_poly_small, caption = 'Table SM1: All protected areas')`

`r knitr::kable(marine_notake_small, caption = 'Table SM2: No-take protection only')`

### Effect of rasterization on inclusion of small MPAs

``` {r create_nonoverlapping_poly_set}

notake_no_intsx_poly_file <- file.path(dir_sa, 'mpa_notake_no_intsx_jun2018.shp')

if(!file.exists(notake_no_intsx_poly_file)) {
  notake_poly <- read_sf(notake_poly_file)
  
  notake_intsx <- st_intersects(notake_poly) %>%
    lapply(as.integer) ### ditch the sgbp class 
  
  intsx_drop <- data.frame(id = 1:length(notake_intsx)) %>%
    mutate(intsx = notake_intsx) %>%
    unnest(intsx) %>%
    filter(intsx > id) %>%
    .$intsx %>% unique()
  ### 468 unique polygons that overlap smaller polygons.
    
  notake_no_intsx <- notake_poly %>%
    filter(!id %in% intsx_drop)
  ### 2862 polygons with no intersections:
  # check <- st_intersects(notake_no_intsx) %>%
  #   sapply(length) %>% all(. == 1)
  write_sf(notake_no_intsx, notake_no_intsx_poly_file)
}
```

``` {r create notake no intersect raster at different res }

notake_1km_file <- file.path(dir_sa, 'notake_no_intsx_rast_by_id.tif')
notake_500m_file <- file.path(dir_sa, 'notake_no_intsx_rast_by_id_500m.tif')
notake_2km_file <- file.path(dir_sa, 'notake_no_intsx_rast_by_id_2km.tif')
notake_3km_file <- file.path(dir_sa, 'notake_no_intsx_rast_by_id_3km.tif')
notake_5km_file <- file.path(dir_sa, 'notake_no_intsx_rast_by_id_5km.tif')

if(!file.exists(notake_1km_file)) {

  notake_no_intsx <- read_sf(notake_no_intsx_poly_file)
  
  ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')

  rast_ocean_1km  <- raster(ocean_1km_file)

  ### rasterize notake areas to 1 km global raster
  notake_rast_1km <- fasterize(sf = notake_no_intsx, 
                               raster = rast_ocean_1km,
                               field  = 'id', 
                               fun    = 'min')

  ### Save the full rasters
  writeRaster(notake_rast_1km, notake_1km_file, 
              progress = 'text',
              overwrite = TRUE)
}
  
if(!file.exists(notake_500m_file)) {

  notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')
  
  rast_ocean_500m  <- raster(ocean_1km_file) %>%
    raster::disaggregate(fact = 2)
  
  ### rasterize notake areas to 1 km global raster
  notake_rast_500m <- fasterize(sf = notake_no_intsx, 
                               raster = rast_ocean_500m,
                               field  = 'id', 
                               fun    = 'min')

  ### Save the full rasters
  writeRaster(notake_rast_500m, notake_500m_file, 
              progress = 'text',
              overwrite = TRUE)
}
  
if(!file.exists(notake_2km_file)) {

  notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')
  
  rast_ocean_2km  <- raster(ocean_1km_file) %>%
    raster::aggregate(fact = 2)
  
  ### rasterize notake areas to 2 km global raster
  notake_rast_2km <- fasterize(sf = notake_no_intsx, 
                               raster = rast_ocean_2km,
                               field  = 'id', 
                               fun    = 'min')

  ### Save the full rasters
  writeRaster(notake_rast_2km, notake_2km_file, 
              progress = 'text',
              overwrite = TRUE)
}
  
if(!file.exists(notake_3km_file)) {

  notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')
  
  rast_ocean_3km  <- raster(ocean_1km_file) %>%
    raster::aggregate(fact = 3)
  
  ### rasterize notake areas to 3 km global raster
  notake_rast_3km <- fasterize(sf = notake_no_intsx, 
                               raster = rast_ocean_3km,
                               field  = 'id', 
                               fun    = 'min')

  ### Save the full rasters
  writeRaster(notake_rast_3km, notake_3km_file, 
              progress = 'text',
              overwrite = TRUE)
}
  
if(!file.exists(notake_5km_file)) {

  notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')
  
  rast_ocean_5km  <- raster(ocean_1km_file) %>%
    raster::aggregate(fact = 5)
  
  ### rasterize notake areas to 2 km global raster
  notake_rast_5km <- fasterize(sf = notake_no_intsx, 
                               raster = rast_ocean_5km,
                               field  = 'id', 
                               fun    = 'min')

  ### Save the full rasters
  writeRaster(notake_rast_5km, notake_5km_file, 
              progress = 'text',
              overwrite = TRUE)
}

```

```{r create comparison dataframes}

get_rast_areas <- function(rast, km2_per_cell = 1) {
  table(values(rast)) %>%
    data.frame() %>%
    rename(id = Var1, cells = Freq) %>%
    mutate(id = as.integer(as.character(id)),
           rast_km2 = cells * km2_per_cell) ### argh, factors
}

compare_areas <- function(polys, rast_df) {
  df <- polys %>%
    as.data.frame() %>%
    select(id, area_km2) %>%
    left_join(rast_df, by = 'id') %>%
    mutate(rast_km2   = ifelse(is.na(rast_km2), 0, rast_km2),
           diff = area_km2 - rast_km2,
           pct_diff = 100 * diff / area_km2)
}
  
compare_file_1km <- file.path(dir_sa, 'area_compare_1km.csv')
compare_file_500m <- file.path(dir_sa, 'area_compare_500m.csv')
compare_file_2km <- file.path(dir_sa, 'area_compare_2km.csv')
compare_file_3km <- file.path(dir_sa, 'area_compare_3km.csv')
compare_file_5km <- file.path(dir_sa, 'area_compare_5km.csv')

### unlink(compare_file_500m)
if(!file.exists(compare_file_1km)) {
  if(!exists('notake_no_intsx')) notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  notake_rast_1km <- raster(notake_1km_file)

  rast_areas_df <- get_rast_areas(notake_rast_1km)
  
  ### combine polygon areas from notake_no_intsx with raster areas
  notake_areas_df <- compare_areas(notake_no_intsx, rast_areas_df)
  
  write_csv(notake_areas_df, compare_file_1km)
}

if(!file.exists(compare_file_500m)) {
  if(!exists('notake_no_intsx')) notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  notake_rast_500m <- raster(notake_500m_file)

  rast_areas_df <- get_rast_areas(notake_rast_500m, km2_per_cell = .25)
  
  ### combine polygon areas from notake_no_intsx with raster areas
  notake_areas_df <- compare_areas(notake_no_intsx, rast_areas_df)
  
  write_csv(notake_areas_df, compare_file_500m)
}

if(!file.exists(compare_file_2km)) {
  if(!exists('notake_no_intsx')) notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  notake_rast_2km <- raster(notake_2km_file)

  rast_areas_df <- get_rast_areas(notake_rast_2km, km2_per_cell = 4)
  
  ### combine polygon areas from notake_no_intsx with raster areas
  notake_areas_df <- compare_areas(notake_no_intsx, rast_areas_df)
  
  write_csv(notake_areas_df, compare_file_2km)
}

if(!file.exists(compare_file_3km)) {
  if(!exists('notake_no_intsx')) notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  notake_rast_3km <- raster(notake_3km_file)

  rast_areas_df <- get_rast_areas(notake_rast_3km, km2_per_cell = 9)
  
  ### combine polygon areas from notake_no_intsx with raster areas
  notake_areas_df <- compare_areas(notake_no_intsx, rast_areas_df)
  
  write_csv(notake_areas_df, compare_file_3km)
}

if(!file.exists(compare_file_5km)) {
  
  if(!exists('notake_no_intsx')) notake_no_intsx <- read_sf(notake_no_intsx_poly_file)

  notake_rast_5km <- raster(notake_5km_file)

  rast_areas_df <- get_rast_areas(notake_rast_5km, km2_per_cell = 25)
  
  ### combine polygon areas from notake_no_intsx with raster areas
  notake_areas_df <- compare_areas(notake_no_intsx, rast_areas_df)
  
  write_csv(notake_areas_df, compare_file_5km)
}

notake_areas_1km_df <- read_csv(compare_file_1km) %>%
  mutate(res = '1km')
notake_areas_2km_df <- read_csv(compare_file_2km) %>%
  mutate(res = '2km')
notake_areas_3km_df <- read_csv(compare_file_3km) %>%
  mutate(res = '3km')
notake_areas_5km_df <- read_csv(compare_file_5km) %>%
  mutate(res = '5km')
notake_areas_500m_df <- read_csv(compare_file_500m) %>%
  mutate(res = '.5km')

notake_areas_df <- bind_rows(notake_areas_500m_df,
                             notake_areas_1km_df,
                             notake_areas_2km_df,
                             notake_areas_3km_df,
                             notake_areas_5km_df) %>%
  select(-cells) %>%
  mutate(res = fct_inorder(res))

```


```{r create size class df}
id_to_class <- notake_areas_1km_df %>%
  as.data.frame() %>% ### not working with raster::subs()
  mutate(size_class = case_when(area_km2 < .001 ~ '< .001',
                                area_km2 < .01  ~ '< .01',
                                area_km2 < .1   ~ '< .1',
                                area_km2 < 1    ~ '< 1',
                                area_km2 < 3    ~ '< 3',
                                area_km2 < 10   ~ '< 10',
                                area_km2 < 100  ~ '< 100',
                                TRUE            ~ '>= 100'),
         size_class = fct_inorder(size_class),
         size_code  = as.integer(size_class)) %>%
  select(id, size_class, poly_area_km2 = area_km2)

```

``` {r compare differences overall}

d_area_all_df <- notake_areas_df %>%
  left_join(id_to_class, by = 'id') %>%
  group_by(res) %>%
  summarize(poly_area_in_class  = sum(area_km2),
            rast_area = sum(rast_km2),
            sum_area_diff = sum(area_km2 - rast_km2),
            rms_area_diff = sqrt(sum((area_km2 - rast_km2)^2) / n()),
            pct_area_diff = (100 * sum_area_diff / poly_area_in_class),
            pct_rmse_diff = (100 * rms_area_diff / poly_area_in_class)) %>%
  mutate(poly_area_in_class = round(poly_area_in_class, 3),
         size_class = 'Total') %>%
  ungroup()

pct_real_diff_all_df <- d_area_all_df %>%
  select(size_class, poly_area_in_class, res, pct_area_diff) %>%
  mutate(res = paste0('∆ Area in class, % (', res, ' cells)'),
         pct_area_diff = round(pct_area_diff, 3)) %>%
  spread(res, pct_area_diff)

pct_rmse_diff_all_df <- d_area_all_df %>%
  select(size_class, poly_area_in_class, res, pct_rmse_diff) %>%
  mutate(res = paste0('RMSE(∆ Area) in class, % (', res, ' cells)'),
         pct_rmse_diff = round(pct_rmse_diff, 3)) %>%
  spread(res, pct_rmse_diff)

```

``` {r compare differences by class}

d_area_df <- notake_areas_df %>%
  left_join(id_to_class, by = 'id') %>%
  group_by(size_class, res) %>%
  summarize(n_in_class = n(),
            poly_area_in_class  = sum(area_km2),
            rast_area_in_class = sum(rast_km2),
            sum_area_diff = sum(area_km2 - rast_km2),
            rms_area_diff = sqrt(sum((area_km2 - rast_km2)^2) / n_in_class),
            pct_area_diff = (100 * sum_area_diff / poly_area_in_class),
            pct_rmse_diff = (100 * rms_area_diff / poly_area_in_class)) %>%
  mutate(poly_area_in_class = round(poly_area_in_class, 3)) %>%
  ungroup()

pct_real_diff_df <- d_area_df %>%
  select(size_class, poly_area_in_class, res, pct_area_diff) %>%
  mutate(res = paste0('∆ Area in class, % (', res, ' cells)'),
         pct_area_diff = round(pct_area_diff, 3)) %>%
  spread(res, pct_area_diff) %>%
  bind_rows(pct_real_diff_all_df) %>%
  rename(`Size class` = size_class,
         `Area in class, km² (polygons)` = poly_area_in_class)

pct_rmse_diff_df <- d_area_df %>%
  select(size_class, poly_area_in_class, res, pct_rmse_diff) %>%
  mutate(res = paste0('RMSE(∆ Area) in class, % (', res, ' cells)'),
         pct_rmse_diff = round(pct_rmse_diff, 3)) %>%
  spread(res, pct_rmse_diff) %>%
  bind_rows(pct_rmse_diff_all_df) %>%
  rename(`Size class` = size_class,
         `Area in class, km² (polygons)` = poly_area_in_class)

write_csv(pct_real_diff_df, 'tableSM3_diff_error.csv')
write_csv(pct_rmse_diff_df, 'tableSM4_rms_error.csv')
```

### Proportional error by size class

Proportional error calculated as $\sum(A_{polygon} - A_{raster}) / \sum(A_{polygon})$.  Negative differences and positive errors may offset each other; the aggregate is the total difference in MPA coverage.

`r knitr::kable(pct_real_diff_df, caption = 'Table SM3: Proportional total difference in area by size class')`

Table SM3 shows that the rasterization process results in a total calculated area that differs from the original dataset by only 0.13%, when positive and negative errors are allowed to balance out.

### RMS error by size class

Proportional RMS error in area calculated as $\sqrt{\frac{1}{N}\sum_{i=1}^N (\frac{A_{polygon} - A_{raster}}{A_{polygon}})^2}$.

`r knitr::kable(pct_rmse_diff_df, caption = 'Table SM4: RMS proportional error in area by size class')`

Table SM4 shows that if high and low errors due to rasterization are counted as a positive difference, then the rasterization process results in a total error of 0.36% relative to the original dataset.

### Number of MPAs dropped due to rasterization

``` {r calc dropped areas}
dropped_areas <- notake_areas_df %>%
  left_join(id_to_class, by = 'id') %>%
  mutate(size_class = fct_inorder(size_class),
         dropped = rast_km2 == 0) 

dropped_all <- dropped_areas %>%
  group_by(res) %>%
  summarize(N = n(),
            n_dropped = sum(dropped),
            area_in_class = sum(area_km2),
            area_dropped  = sum(area_km2 * dropped),
            pct_dropped = (100 * n_dropped / n()),
            pct_area_dropped = (100 * area_dropped / area_in_class),
            `Size class` = 'Total') %>%
  select(`Size class`,
         N,
         `Area in class, km²` = area_in_class,
         res,
         pct_dropped,
         pct_area_dropped)

dropped_by_class <- dropped_areas %>%
  group_by(res, size_class) %>%
  summarize(N = n(),
            n_dropped = sum(dropped),
            area_in_class = sum(area_km2),
            area_dropped  = sum(area_km2 * dropped),
            pct_dropped = (100 * n_dropped / N),
            pct_area_dropped = (100 * area_dropped / area_in_class)) %>%
  ungroup() %>%
  select(`Size class` = size_class,
         N,
         `Area in class, km²` = area_in_class,
         res,
         pct_dropped,
         pct_area_dropped) %>%
  bind_rows(dropped_all) %>%
  mutate(`Size class` = fct_inorder(`Size class`))


dropped_pct_df <- dropped_by_class %>%
  select(-pct_area_dropped) %>%
  mutate(res = paste0('% dropped (', res, ' cells)')) %>%
  spread(res, pct_dropped)

dropped_area_df <- dropped_by_class %>%
  select(-pct_dropped) %>%
  mutate(res = paste0('% area dropped (', res, ' cells)')) %>%
  spread(res, pct_area_dropped)

write_csv(dropped_pct_df, 'tableSM5_pct_dropped.csv')
write_csv(dropped_area_df, 'tableSM6_pct_area_dropped.csv')
```

MPA presence within a cell is determined by the overlap of the MPA polygon and the center of the cell.  For very small MPAs, or MPAs with narrow aspect ratios, the polygon may not overlap the center, and thus may not be counted.  

`r knitr::kable(dropped_pct_df, caption = 'Table SM5: Percent of MPAs dropped by size class')`

`r knitr::kable(dropped_area_df, caption = 'Table SM6: Percent of MPA area dropped by size class')`

Table SM5 shows that, indeed, many small MPAs are not included in the final raster depending on the cell resolution.  Unsurprisingly, the smaller the MPA, the more likely to be dropped.  Dropped MPAs will result in a certain underestimate of MPA coverage globally, though this is quite small: even at 5 km x 5 km cell resolution, the total difference due to these dropped MPAs is only 0.067% of the MPA coverage of this sample dataset, and only 0.0007% at 0.5 km x 0.5 km resolution.  These results overestimate the loss, since many of these small MPAs would be overlapped by larger MPAs (and thus accounting for that protection).  Additionally, this sample dataset removes larger MPAs that would obscure smaller MPAs, thus the total area of the sample dataset is biased toward smaller MPAs, inflating the relative proportion of dropped area.

## Calculating protected area at 100 km^2^ analysis resolution

The biodiversity risk analysis is performed at a resolution of 10 km x 10 km cells.  To determine the proportional coverage of MPAs at this analysis resolution, we count the number of protected cells at the MPA raster resolution that fall within a single 10 km x 10 km analysis cell, multiply by the MPA raster cell area, and divide by the analysis cell area, i.e. 100 km^2^.  This results in a proportional protection from 0 to 1 in each 10 km x 10 km analysis cell.
$$\text{MPA protection} = \frac{N_{cells,MPA} * A_{cell, MPA}}{A_{cell, analysis}} = \frac{N_{cells,MPA} * .25 km^2}{100 km^2}$$

